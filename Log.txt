Day One

* 1st Star:
Made Day class, Scanner with Day One.txt as file in.  Read one line at a time stored as string.  
Have two loops that iterate through the string at both ends moving inward until the first digit is found for both.
Store both digits in order (L/R) as Strings, concatenate together, cast into integer.
Count up the total calculated integer values for each line.

[thought while writing -- use two pointers in while loop, start and end, move inward]

** 2nd Star:
Created HashMap of String (e.g "five"), Integer (e.g 5) pairs.
Examined string of each line for any key in HashMap, scanning with two pointers outwardly, also scanning for any digits.
Built new string concatenating values of keys scanned and digits scanned.
Finished with same two loops from 1st Star above.

=====

Day Two:

* 1st Star:
Went with an OOP approach.  At first tried to be hilariously overdetailed with objects but it slowly tapered down.
Scanner reads down Day Two.txt, turning lines into games.  Each game has an ArrayList of dice draws as int[] (red, green, blue) and an incrementing id integer.
If any dice draw went over a maximum allowed number, that game is lost.  Otherwise, the game is won, and the game id is added to an accumulating final total.
Probably could have made this a little cleaner, faster, neater, but it works.'

** 2nd Star:
I just went in there thinking about the values.  Found where to slot the code in.
Find the max number associated with each color in all draws per game.  Multiply max numbers together for power level.  Sum all 100 for final total.
I spent more time on the System.out formating than the code.

=====

Day 3

* 1st Star:
Lots of stuff here.  I loaded the engine schematic into a 2D character array.  Created a set of all known symbols to look for during scanning.
I created a function that scans all eight adjacent neighbors around each node.  Had the idea of using an 8 bit binary number as flags with bitwise operations so I tried it.
Each square had an 8 bit binary "edgelist" with each 1 representing a "scannable" cardinal direction for that square, in this order: N, NE, E, SE, S, SW, W, NW.
This helped to avoid scanning out of bounds on all edge nodes.
Scanned across the schematic.  If I found a digit, I scanned around that digit for a symbol using bitwise operators to guide my scanning directions.
If a symbol was found, the full part number was compiled and added to total sum.
All other characters were ignored.

** 2nd Star:
I refactored a lot of the code that would be duplicated during this part into separate methods.  Ensuring both solves still worked afterward was a bit overwhelming.
I need to practice sectioning my code a little better, and reducing duplicate lines.
I scanned for gears (*) in the character array.  When one was found, I scanned around the gear for digits.
If digit was found, I compiled the digit and added to an ArrayList.  If the size of the ArrayList was greater than 1, the gear ratio was calculated and added to final total.

=====

Day 4

* 1st Star:


Files Log:
Created Log
Created Day interface w/ compute method.  Implemented in DayOne class.  Created separate Main file for easy compliation.
Moved all code in DayOne into required compute method.
Created DayTwo solution.
Edited Main to add DayTwo and compute answer.
Edited Main for Day Three.